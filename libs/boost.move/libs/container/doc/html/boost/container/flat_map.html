<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Class template flat_map</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.67.0">
<link rel="start" href="../../index.html" title="Chapter 1. Boost.Container">
<link rel="up" href="../../boost_container_reference.html#header.boost.container.flat_map_hpp" title="Header &lt;boost/container/flat_map.hpp&gt;">
<link rel="prev" href="deque.html" title="Class template deque">
<link rel="next" href="flat_multimap.html" title="Class template flat_multimap">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="deque.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../boost_container_reference.html#header.boost.container.flat_map_hpp"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="flat_multimap.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.container.flat_map"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template flat_map</span></h2>
<p>boost::container::flat_map &#8212; </p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Key, <span class="bold"><strong>typename</strong></span> T, <span class="bold"><strong>typename</strong></span> Pred, <span class="bold"><strong>typename</strong></span> Alloc&gt; 
<span class="bold"><strong>class</strong></span> <a href="flat_map.html" title="Class template flat_map">flat_map</a> {
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// types</em></span>
  <span class="bold"><strong>typedef</strong></span> tree_t::key_type               <a name="boost.container.flat_map.key_type"></a>key_type;              
  <span class="bold"><strong>typedef</strong></span> tree_t::value_type             <a name="boost.container.flat_map.value_type"></a>value_type;            
  <span class="bold"><strong>typedef</strong></span> tree_t::pointer                <a name="boost.container.flat_map.pointer"></a>pointer;               
  <span class="bold"><strong>typedef</strong></span> tree_t::const_pointer          <a name="boost.container.flat_map.const_pointer"></a>const_pointer;         
  <span class="bold"><strong>typedef</strong></span> tree_t::reference              <a name="boost.container.flat_map.reference"></a>reference;             
  <span class="bold"><strong>typedef</strong></span> tree_t::const_reference        <a name="boost.container.flat_map.const_reference"></a>const_reference;       
  <span class="bold"><strong>typedef</strong></span> tree_t::value_compare          <a name="boost.container.flat_map.value_compare"></a>value_compare;         
  <span class="bold"><strong>typedef</strong></span> T                              <a name="boost.container.flat_map.mapped_type"></a>mapped_type;           
  <span class="bold"><strong>typedef</strong></span> tree_t::key_compare            <a name="boost.container.flat_map.key_compare"></a>key_compare;           
  <span class="bold"><strong>typedef</strong></span> tree_t::iterator               <a name="boost.container.flat_map.iterator"></a>iterator;              
  <span class="bold"><strong>typedef</strong></span> tree_t::const_iterator         <a name="boost.container.flat_map.const_iterator"></a>const_iterator;        
  <span class="bold"><strong>typedef</strong></span> tree_t::reverse_iterator       <a name="boost.container.flat_map.reverse_iterator"></a>reverse_iterator;      
  <span class="bold"><strong>typedef</strong></span> tree_t::const_reverse_iterator <a name="boost.container.flat_map.const_reverse_iterator"></a>const_reverse_iterator;
  <span class="bold"><strong>typedef</strong></span> tree_t::size_type              <a name="boost.container.flat_map.size_type"></a>size_type;             
  <span class="bold"><strong>typedef</strong></span> tree_t::difference_type        <a name="boost.container.flat_map.difference_type"></a>difference_type;       
  <span class="bold"><strong>typedef</strong></span> tree_t::allocator_type         <a name="boost.container.flat_map.allocator_type"></a>allocator_type;        
  <span class="bold"><strong>typedef</strong></span> tree_t::stored_allocator_type  <a name="boost.container.flat_map.stored_allocator_type"></a>stored_allocator_type; 

  <span class="emphasis"><em>// <a href="flat_map.html#boost.container.flat_mapconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <a href="flat_map.html#id282081-bb">flat_map</a>(<span class="bold"><strong>const</strong></span> Pred &amp; = Pred(), <span class="bold"><strong>const</strong></span> allocator_type &amp; = allocator_type());
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> InputIterator&gt; 
    <a href="flat_map.html#id282124-bb">flat_map</a>(InputIterator, InputIterator, <span class="bold"><strong>const</strong></span> Pred &amp; = Pred(), 
             <span class="bold"><strong>const</strong></span> allocator_type &amp; = allocator_type());
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> InputIterator&gt; 
    <a href="flat_map.html#id282194-bb">flat_map</a>(ordered_unique_range_t, InputIterator, InputIterator, 
             <span class="bold"><strong>const</strong></span> Pred &amp; = Pred(), 
             <span class="bold"><strong>const</strong></span> allocator_type &amp; = allocator_type());
  <a href="flat_map.html#id282282-bb">flat_map</a>(<span class="bold"><strong>const</strong></span> <a href="flat_map.html" title="Class template flat_map">flat_map</a>&lt; Key, T, Pred, Alloc &gt; &amp;);
  <a href="flat_map.html#id282316-bb">flat_map</a>(<a href="flat_map.html" title="Class template flat_map">flat_map</a> &amp;&amp;);
  flat_map&amp; <a href="flat_map.html#id282358-bb"><span class="bold"><strong>operator</strong></span>=</a>(<span class="bold"><strong>const</strong></span> <a href="flat_map.html" title="Class template flat_map">flat_map</a> &amp;);
  flat_map&amp; <a href="flat_map.html#id282391-bb"><span class="bold"><strong>operator</strong></span>=</a>(<a href="flat_map.html" title="Class template flat_map">flat_map</a> &amp;&amp;);

  <span class="emphasis"><em>// <a href="flat_map.html#id279915-bb">public member functions</a></em></span>
  <span class="type">key_compare</span> <a href="flat_map.html#id279919-bb">key_comp</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">value_compare</span> <a href="flat_map.html#id279950-bb">value_comp</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">allocator_type</span> <a href="flat_map.html#id279980-bb">get_allocator</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>const</strong></span> stored_allocator_type &amp;</span> <a href="flat_map.html#id280010-bb">get_stored_allocator</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">stored_allocator_type &amp;</span> <a href="flat_map.html#id280021-bb">get_stored_allocator</a>() ;
  <span class="type">iterator</span> <a href="flat_map.html#id280031-bb">begin</a>() ;
  <span class="type">const_iterator</span> <a href="flat_map.html#id280070-bb">begin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_iterator</span> <a href="flat_map.html#id280109-bb">cbegin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">iterator</span> <a href="flat_map.html#id280148-bb">end</a>() ;
  <span class="type">const_iterator</span> <a href="flat_map.html#id280187-bb">end</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_iterator</span> <a href="flat_map.html#id280226-bb">cend</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">reverse_iterator</span> <a href="flat_map.html#id280264-bb">rbegin</a>() ;
  <span class="type">const_reverse_iterator</span> <a href="flat_map.html#id280304-bb">rbegin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_reverse_iterator</span> <a href="flat_map.html#id280343-bb">crbegin</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">reverse_iterator</span> <a href="flat_map.html#id280382-bb">rend</a>() ;
  <span class="type">const_reverse_iterator</span> <a href="flat_map.html#id280422-bb">rend</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">const_reverse_iterator</span> <a href="flat_map.html#id280461-bb">crend</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a href="flat_map.html#id280500-bb">empty</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a href="flat_map.html#id280539-bb">size</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a href="flat_map.html#id280578-bb">max_size</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">T &amp;</span> <a href="flat_map.html#id280616-bb"><span class="bold"><strong>operator</strong></span>[]</a>(<span class="bold"><strong>const</strong></span> key_type &amp;) ;
  <span class="type">T &amp;</span> <a href="flat_map.html#id280648-bb"><span class="bold"><strong>operator</strong></span>[]</a>(key_type &amp;&amp;) ;
  <span class="type">T &amp;</span> <a href="flat_map.html#id280679-bb">at</a>(<span class="bold"><strong>const</strong></span> key_type &amp;) ;
  <span class="type"><span class="bold"><strong>const</strong></span> T &amp;</span> <a href="flat_map.html#id280704-bb">at</a>(<span class="bold"><strong>const</strong></span> key_type &amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a href="flat_map.html#id280728-bb">swap</a>(<a href="flat_map.html" title="Class template flat_map">flat_map</a> &amp;) ;
  <span class="type">std::pair&lt; iterator, <span class="bold"><strong>bool</strong></span> &gt;</span> <a href="flat_map.html#id280776-bb">insert</a>(<span class="bold"><strong>const</strong></span> value_type &amp;) ;
  <span class="type">std::pair&lt; iterator, <span class="bold"><strong>bool</strong></span> &gt;</span> <a href="flat_map.html#id280836-bb">insert</a>(value_type &amp;&amp;) ;
  <span class="type">std::pair&lt; iterator, <span class="bold"><strong>bool</strong></span> &gt;</span> <a href="flat_map.html#id280898-bb">insert</a>(impl_value_type &amp;&amp;) ;
  <span class="type">iterator</span> <a href="flat_map.html#id280960-bb">insert</a>(const_iterator, <span class="bold"><strong>const</strong></span> value_type &amp;) ;
  <span class="type">iterator</span> <a href="flat_map.html#id281029-bb">insert</a>(const_iterator, value_type &amp;&amp;) ;
  <span class="type">iterator</span> <a href="flat_map.html#id281094-bb">insert</a>(const_iterator, impl_value_type &amp;&amp;) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> InputIterator&gt; <span class="type"><span class="bold"><strong>void</strong></span></span> <a href="flat_map.html#id281162-bb">insert</a>(InputIterator, InputIterator) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>class</strong></span>... Args&gt; <span class="type">iterator</span> <a href="flat_map.html#id281237-bb">emplace</a>(Args &amp;&amp;...) ;
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>class</strong></span>... Args&gt; <span class="type">iterator</span> <a href="flat_map.html#id281311-bb">emplace_hint</a>(const_iterator, Args &amp;&amp;...) ;
  <span class="type">iterator</span> <a href="flat_map.html#id281393-bb">erase</a>(const_iterator) ;
  <span class="type">size_type</span> <a href="flat_map.html#id281452-bb">erase</a>(<span class="bold"><strong>const</strong></span> key_type &amp;) ;
  <span class="type">iterator</span> <a href="flat_map.html#id281500-bb">erase</a>(const_iterator, const_iterator) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a href="flat_map.html#id281565-bb">clear</a>() ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a href="flat_map.html#id281603-bb">shrink_to_fit</a>() ;
  <span class="type">iterator</span> <a href="flat_map.html#id281643-bb">find</a>(<span class="bold"><strong>const</strong></span> key_type &amp;) ;
  <span class="type">const_iterator</span> <a href="flat_map.html#id281681-bb">find</a>(<span class="bold"><strong>const</strong></span> key_type &amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a href="flat_map.html#id281720-bb">count</a>(<span class="bold"><strong>const</strong></span> key_type &amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type">iterator</span> <a href="flat_map.html#id281758-bb">lower_bound</a>(<span class="bold"><strong>const</strong></span> key_type &amp;) ;
  <span class="type">const_iterator</span> <a href="flat_map.html#id281796-bb">lower_bound</a>(<span class="bold"><strong>const</strong></span> key_type &amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type">iterator</span> <a href="flat_map.html#id281835-bb">upper_bound</a>(<span class="bold"><strong>const</strong></span> key_type &amp;) ;
  <span class="type">const_iterator</span> <a href="flat_map.html#id281874-bb">upper_bound</a>(<span class="bold"><strong>const</strong></span> key_type &amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type">std::pair&lt; iterator, iterator &gt;</span> <a href="flat_map.html#id281912-bb">equal_range</a>(<span class="bold"><strong>const</strong></span> key_type &amp;) ;
  <span class="type">std::pair&lt; const_iterator, const_iterator &gt;</span> 
  <a href="flat_map.html#id281950-bb">equal_range</a>(<span class="bold"><strong>const</strong></span> key_type &amp;) <span class="bold"><strong>const</strong></span>;
  <span class="type">size_type</span> <a href="flat_map.html#id281989-bb">capacity</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a href="flat_map.html#id282029-bb">reserve</a>(size_type) ;
};</pre></div>
<div class="refsect1" lang="en">
<a name="id484194"></a><h2>Description</h2>
<p>A flat_map is a kind of associative container that supports unique keys (contains at most one of each key value) and provides for fast retrieval of values of another type T based on the keys. The flat_map class supports random-access iterators.</p>
<p>A flat_map satisfies all of the requirements of a container and of a reversible container and of an associative container. A flat_map also provides most operations described for unique keys. For a flat_map&lt;Key,T&gt; the key_type is Key and the value_type is std::pair&lt;Key,T&gt; (unlike std::map&lt;Key, T&gt; which value_type is std::pair&lt;<span class="bold"><strong>const</strong></span> Key, T&gt;).</p>
<p>Pred is the ordering function for Keys (e.g. std::less&lt;Key&gt;).</p>
<p>Alloc is the allocator to allocate the value_types (e.g. allocator&lt; std::pair&lt;Key, T&gt; &gt;).</p>
<p>flat_map is similar to std::map but it's implemented like an ordered vector. This means that inserting a new element into a flat_map invalidates previous iterators and references</p>
<p>Erasing an element of a flat_map invalidates iterators and references pointing to elements that come after (their keys are bigger) the erased element. </p>
<div class="refsect2" lang="en">
<a name="id484242"></a><h3>
<a name="boost.container.flat_mapconstruct-copy-destruct"></a><code class="computeroutput">flat_map</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id282081-bb"></a>flat_map(<span class="bold"><strong>const</strong></span> Pred &amp; comp = Pred(), 
         <span class="bold"><strong>const</strong></span> allocator_type &amp; a = allocator_type());</pre>
<p><span class="bold"><strong>Effects</strong></span>: Constructs an empty flat_map using the specified comparison object and allocator.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> InputIterator&gt; 
  <a name="id282124-bb"></a>flat_map(InputIterator first, InputIterator last, 
           <span class="bold"><strong>const</strong></span> Pred &amp; comp = Pred(), 
           <span class="bold"><strong>const</strong></span> allocator_type &amp; a = allocator_type());</pre>
<p><span class="bold"><strong>Effects</strong></span>: Constructs an empty flat_map using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> InputIterator&gt; 
  <a name="id282194-bb"></a>flat_map(ordered_unique_range_t, InputIterator first, InputIterator last, 
           <span class="bold"><strong>const</strong></span> Pred &amp; comp = Pred(), 
           <span class="bold"><strong>const</strong></span> allocator_type &amp; a = allocator_type());</pre>
<p><span class="bold"><strong>Effects</strong></span>: Constructs an empty flat_map using the specified comparison object and allocator, and inserts elements from the ordered unique range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</p>
<p><span class="bold"><strong>Requires</strong></span>: [first ,last) must be ordered according to the predicate and must be unique values.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear in N. </p>
</li>
<li>
<pre class="literallayout"><a name="id282282-bb"></a>flat_map(<span class="bold"><strong>const</strong></span> <a href="flat_map.html" title="Class template flat_map">flat_map</a>&lt; Key, T, Pred, Alloc &gt; &amp; x);</pre>
<p><span class="bold"><strong>Effects</strong></span>: Copy constructs a flat_map.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear in x.size(). </p>
</li>
<li>
<pre class="literallayout"><a name="id282316-bb"></a>flat_map(<a href="flat_map.html" title="Class template flat_map">flat_map</a> &amp;&amp; x);</pre>
<p><span class="bold"><strong>Effects</strong></span>: Move constructs a flat_map. Constructs *this using x's resources.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Construct.</p>
<p><span class="bold"><strong>Postcondition</strong></span>: x is emptied. </p>
</li>
<li>
<pre class="literallayout">flat_map&amp; <a name="id282358-bb"></a><span class="bold"><strong>operator</strong></span>=(<span class="bold"><strong>const</strong></span> <a href="flat_map.html" title="Class template flat_map">flat_map</a> &amp; x);</pre>
<p><span class="bold"><strong>Effects</strong></span>: Makes *this a copy of x.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear in x.size(). </p>
</li>
<li>
<pre class="literallayout">flat_map&amp; <a name="id282391-bb"></a><span class="bold"><strong>operator</strong></span>=(<a href="flat_map.html" title="Class template flat_map">flat_map</a> &amp;&amp; mx);</pre>
<p><span class="bold"><strong>Effects</strong></span>: Move constructs a flat_map. Constructs *this using x's resources.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Construct.</p>
<p><span class="bold"><strong>Postcondition</strong></span>: x is emptied. </p>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id484690"></a><h3>
<a name="id279915-bb"></a><code class="computeroutput">flat_map</code> public member functions</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type">key_compare</span> <a name="id279919-bb"></a>key_comp() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns the comparison object out of which a was constructed.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">value_compare</span> <a name="id279950-bb"></a>value_comp() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns an object of value_compare constructed out of the comparison object.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">allocator_type</span> <a name="id279980-bb"></a>get_allocator() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a copy of the Allocator that was passed to the object's constructor.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>const</strong></span> stored_allocator_type &amp;</span> <a name="id280010-bb"></a>get_stored_allocator() <span class="bold"><strong>const</strong></span>;</pre></li>
<li><pre class="literallayout"><span class="type">stored_allocator_type &amp;</span> <a name="id280021-bb"></a>get_stored_allocator() ;</pre></li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id280031-bb"></a>begin() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns an iterator to the first element contained in the container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id280070-bb"></a>begin() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_iterator to the first element contained in the container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id280109-bb"></a>cbegin() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_iterator to the first element contained in the container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id280148-bb"></a>end() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns an iterator to the end of the container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id280187-bb"></a>end() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_iterator to the end of the container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id280226-bb"></a>cend() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_iterator to the end of the container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">reverse_iterator</span> <a name="id280264-bb"></a>rbegin() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a reverse_iterator pointing to the beginning of the reversed container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_reverse_iterator</span> <a name="id280304-bb"></a>rbegin() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_reverse_iterator</span> <a name="id280343-bb"></a>crbegin() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">reverse_iterator</span> <a name="id280382-bb"></a>rend() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a reverse_iterator pointing to the end of the reversed container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_reverse_iterator</span> <a name="id280422-bb"></a>rend() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_reverse_iterator pointing to the end of the reversed container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_reverse_iterator</span> <a name="id280461-bb"></a>crend() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns a const_reverse_iterator pointing to the end of the reversed container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id280500-bb"></a>empty() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns true if the container contains no elements.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id280539-bb"></a>size() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns the number of the elements contained in the container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id280578-bb"></a>max_size() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Returns the largest possible size of the container.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">T &amp;</span> <a name="id280616-bb"></a><span class="bold"><strong>operator</strong></span>[](<span class="bold"><strong>const</strong></span> key_type &amp; k) ;</pre>
<p>Effects: If there is no key equivalent to x in the flat_map, inserts value_type(x, T()) into the flat_map.</p>
<p>Returns: A reference to the mapped_type corresponding to x in *this.</p>
<p>Complexity: Logarithmic. </p>
</li>
<li>
<pre class="literallayout"><span class="type">T &amp;</span> <a name="id280648-bb"></a><span class="bold"><strong>operator</strong></span>[](key_type &amp;&amp; mk) ;</pre>
<p>Effects: If there is no key equivalent to x in the flat_map, inserts value_type(move(x), T()) into the flat_map (the key is move-constructed)</p>
<p>Returns: A reference to the mapped_type corresponding to x in *this.</p>
<p>Complexity: Logarithmic. </p>
</li>
<li>
<pre class="literallayout"><span class="type">T &amp;</span> <a name="id280679-bb"></a>at(<span class="bold"><strong>const</strong></span> key_type &amp; k) ;</pre>
<p>Returns: A reference to the element whose key is equivalent to x. Throws: An exception object of type out_of_range if no such element is present. Complexity: logarithmic. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>const</strong></span> T &amp;</span> <a name="id280704-bb"></a>at(<span class="bold"><strong>const</strong></span> key_type &amp; k) <span class="bold"><strong>const</strong></span>;</pre>
<p>Returns: A reference to the element whose key is equivalent to x. Throws: An exception object of type out_of_range if no such element is present. Complexity: logarithmic. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id280728-bb"></a>swap(<a href="flat_map.html" title="Class template flat_map">flat_map</a> &amp; x) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type">std::pair&lt; iterator, <span class="bold"><strong>bool</strong></span> &gt;</span> <a name="id280776-bb"></a>insert(<span class="bold"><strong>const</strong></span> value_type &amp; x) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Inserts x if and only if there is no element in the container with key equivalent to the key of x.</p>
<p><span class="bold"><strong>Returns</strong></span>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</p>
<p><span class="bold"><strong>Note</strong></span>: If an element it's inserted it might invalidate elements. </p>
</li>
<li>
<pre class="literallayout"><span class="type">std::pair&lt; iterator, <span class="bold"><strong>bool</strong></span> &gt;</span> <a name="id280836-bb"></a>insert(value_type &amp;&amp; x) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Inserts a new value_type move constructed from the pair if and only if there is no element in the container with key equivalent to the key of x.</p>
<p><span class="bold"><strong>Returns</strong></span>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</p>
<p><span class="bold"><strong>Note</strong></span>: If an element it's inserted it might invalidate elements. </p>
</li>
<li>
<pre class="literallayout"><span class="type">std::pair&lt; iterator, <span class="bold"><strong>bool</strong></span> &gt;</span> <a name="id280898-bb"></a>insert(impl_value_type &amp;&amp; x) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Inserts a new value_type move constructed from the pair if and only if there is no element in the container with key equivalent to the key of x.</p>
<p><span class="bold"><strong>Returns</strong></span>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</p>
<p><span class="bold"><strong>Note</strong></span>: If an element it's inserted it might invalidate elements. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id280960-bb"></a>insert(const_iterator position, <span class="bold"><strong>const</strong></span> value_type &amp; x) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Inserts a copy of x in the container if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</p>
<p><span class="bold"><strong>Returns</strong></span>: An iterator pointing to the element with key equivalent to the key of x.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</p>
<p><span class="bold"><strong>Note</strong></span>: If an element it's inserted it might invalidate elements. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id281029-bb"></a>insert(const_iterator position, value_type &amp;&amp; x) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Inserts an element move constructed from x in the container. p is a hint pointing to where the insert should start to search.</p>
<p><span class="bold"><strong>Returns</strong></span>: An iterator pointing to the element with key equivalent to the key of x.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</p>
<p><span class="bold"><strong>Note</strong></span>: If an element it's inserted it might invalidate elements. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id281094-bb"></a>insert(const_iterator position, impl_value_type &amp;&amp; x) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Inserts an element move constructed from x in the container. p is a hint pointing to where the insert should start to search.</p>
<p><span class="bold"><strong>Returns</strong></span>: An iterator pointing to the element with key equivalent to the key of x.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</p>
<p><span class="bold"><strong>Note</strong></span>: If an element it's inserted it might invalidate elements. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> InputIterator&gt; 
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id281162-bb"></a>insert(InputIterator first, InputIterator last) ;</pre>
<p><span class="bold"><strong>Requires</strong></span>: i, j are not iterators into *this.</p>
<p><span class="bold"><strong>Effects</strong></span>: inserts each element from the range [i,j) if and only if there is no element with key equivalent to the key of that element.</p>
<p><span class="bold"><strong>Complexity</strong></span>: N log(size()+N) (N is the distance from i to j) search time plus N*size() insertion time.</p>
<p><span class="bold"><strong>Note</strong></span>: If an element it's inserted it might invalidate elements. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>class</strong></span>... Args&gt; <span class="type">iterator</span> <a name="id281237-bb"></a>emplace(Args &amp;&amp;... args) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... if and only if there is no element in the container with key equivalent to the key of x.</p>
<p><span class="bold"><strong>Returns</strong></span>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</p>
<p><span class="bold"><strong>Note</strong></span>: If an element it's inserted it might invalidate elements. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>class</strong></span>... Args&gt; 
  <span class="type">iterator</span> <a name="id281311-bb"></a>emplace_hint(const_iterator hint, Args &amp;&amp;... args) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... in the container if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</p>
<p><span class="bold"><strong>Returns</strong></span>: An iterator pointing to the element with key equivalent to the key of x.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</p>
<p><span class="bold"><strong>Note</strong></span>: If an element it's inserted it might invalidate elements. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id281393-bb"></a>erase(const_iterator position) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Erases the element pointed to by position.</p>
<p><span class="bold"><strong>Returns</strong></span>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to the elements with keys bigger than position</p>
<p><span class="bold"><strong>Note</strong></span>: Invalidates elements with keys not less than the erased element. </p>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id281452-bb"></a>erase(<span class="bold"><strong>const</strong></span> key_type &amp; x) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Erases all elements in the container with key equivalent to x.</p>
<p><span class="bold"><strong>Returns</strong></span>: Returns the number of erased elements.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id281500-bb"></a>erase(const_iterator first, const_iterator last) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Erases all the elements in the range [first, last).</p>
<p><span class="bold"><strong>Returns</strong></span>: Returns last.</p>
<p><span class="bold"><strong>Complexity</strong></span>: size()*N where N is the distance from first to last.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id281565-bb"></a>clear() ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: erase(a.begin(),a.end()).</p>
<p><span class="bold"><strong>Postcondition</strong></span>: size() == 0.</p>
<p><span class="bold"><strong>Complexity</strong></span>: linear in size(). </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id281603-bb"></a>shrink_to_fit() ;</pre>
<span class="bold"><strong>Effects</strong></span><p><span class="bold"><strong>Throws</strong></span>: If memory allocation throws, or T's copy constructor throws.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Linear to size(). </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id281643-bb"></a>find(<span class="bold"><strong>const</strong></span> key_type &amp; x) ;</pre>
<p><span class="bold"><strong>Returns</strong></span>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic. </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id281681-bb"></a>find(<span class="bold"><strong>const</strong></span> key_type &amp; x) <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Returns</strong></span>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic.s </p>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id281720-bb"></a>count(<span class="bold"><strong>const</strong></span> key_type &amp; x) <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Returns</strong></span>: The number of elements with key equivalent to x.</p>
<p><span class="bold"><strong>Complexity</strong></span>: log(size())+count(k) </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id281758-bb"></a>lower_bound(<span class="bold"><strong>const</strong></span> key_type &amp; x) ;</pre>
<p><span class="bold"><strong>Returns</strong></span>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id281796-bb"></a>lower_bound(<span class="bold"><strong>const</strong></span> key_type &amp; x) <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Returns</strong></span>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic </p>
</li>
<li>
<pre class="literallayout"><span class="type">iterator</span> <a name="id281835-bb"></a>upper_bound(<span class="bold"><strong>const</strong></span> key_type &amp; x) ;</pre>
<p><span class="bold"><strong>Returns</strong></span>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic </p>
</li>
<li>
<pre class="literallayout"><span class="type">const_iterator</span> <a name="id281874-bb"></a>upper_bound(<span class="bold"><strong>const</strong></span> key_type &amp; x) <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Returns</strong></span>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic </p>
</li>
<li>
<pre class="literallayout"><span class="type">std::pair&lt; iterator, iterator &gt;</span> <a name="id281912-bb"></a>equal_range(<span class="bold"><strong>const</strong></span> key_type &amp; x) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic </p>
</li>
<li>
<pre class="literallayout"><span class="type">std::pair&lt; const_iterator, const_iterator &gt;</span> 
<a name="id281950-bb"></a>equal_range(<span class="bold"><strong>const</strong></span> key_type &amp; x) <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</p>
<p><span class="bold"><strong>Complexity</strong></span>: Logarithmic </p>
</li>
<li>
<pre class="literallayout"><span class="type">size_type</span> <a name="id281989-bb"></a>capacity() <span class="bold"><strong>const</strong></span>;</pre>
<p><span class="bold"><strong>Effects</strong></span>: Number of elements for which memory has been allocated. capacity() is always greater than or equal to size().</p>
<p><span class="bold"><strong>Throws</strong></span>: Nothing.</p>
<p><span class="bold"><strong>Complexity</strong></span>: Constant. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id282029-bb"></a>reserve(size_type count) ;</pre>
<p><span class="bold"><strong>Effects</strong></span>: If n is less than or equal to capacity(), this call has no effect. Otherwise, it is a request for allocation of additional memory. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</p>
<p><span class="bold"><strong>Throws</strong></span>: If memory allocation allocation throws or T's copy constructor throws.</p>
<p><span class="bold"><strong>Note</strong></span>: If capacity() is less than "count", iterators and references to to values might be invalidated. </p>
</li>
</ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2009 -2009 Ion Gaztañaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="deque.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../boost_container_reference.html#header.boost.container.flat_map_hpp"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="flat_multimap.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
