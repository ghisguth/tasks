<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Class template atomic</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="Chapter&#160;1.&#160;Boost.Atomic">
<link rel="up" href="../atomic/reference.html#header..var.lib.build.boost-trunk.libs.atomic.doc.atomic_hpp" title="Header &lt;boost/atomic.hpp&gt;">
<link rel="prev" href="../atomic/reference.html" title="Reference">
<link rel="next" href="memory_order.html" title="Type memory_order">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../atomic/reference.html"><img src="../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../atomic/reference.html#header..var.lib.build.boost-trunk.libs.atomic.doc.atomic_hpp"><img src="../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="memory_order.html"><img src="../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.atomic"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template atomic</span></h2>
<p>boost::atomic &#8212; Atomic datatype. </p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="emphasis"><em>// In header: &lt;<a class="link" href="../atomic/reference.html#header..var.lib.build.boost-trunk.libs.atomic.doc.atomic_hpp" title="Header &lt;boost/atomic.hpp&gt;">boost/atomic.hpp</a>&gt;

</em></span><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> Type&gt; 
<span class="bold"><strong>class</strong></span> <a class="link" href="atomic.html" title="Class template atomic">atomic</a> {
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// <a class="link" href="atomic.html#boost.atomicconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <a class="link" href="atomic.html#id2422623-bb">atomic</a>();
  <a class="link" href="atomic.html#id2457688-bb">atomic</a>(Type);
  <a class="link" href="atomic.html#id2457730-bb">atomic</a>(<span class="bold"><strong>const</strong></span> <a class="link" href="atomic.html" title="Class template atomic">atomic</a> &amp;);
  atomic&amp; <a class="link" href="atomic.html#id2457704-bb"><span class="bold"><strong>operator</strong></span>=</a>(Type);
  atomic&amp; <a class="link" href="atomic.html#id2457742-bb"><span class="bold"><strong>operator</strong></span>=</a>(<span class="bold"><strong>const</strong></span> <a class="link" href="atomic.html" title="Class template atomic">atomic</a> &amp;);

  <span class="emphasis"><em>// <a class="link" href="atomic.html#id2396681-bb">public member functions</a></em></span>
  <span class="type">Type</span> <a class="link" href="atomic.html#id2396684-bb">load</a>(memory_order = memory_order_seq_cst) <span class="bold"><strong>const</strong></span>;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="atomic.html#id2396740-bb">store</a>(Type, memory_order = memory_order_seq_cst) ;
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="atomic.html#id2396795-bb">compare_exchange_weak</a>(Type &amp;, Type, 
                             memory_order = memory_order_seq_cst) ;
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="atomic.html#id2396922-bb">compare_exchange_weak</a>(Type &amp;, Type, memory_order, memory_order) ;
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="atomic.html#id2397005-bb">compare_exchange_strong</a>(Type &amp;, Type, 
                               memory_order = memory_order_seq_cst) ;
  <span class="type"><span class="bold"><strong>bool</strong></span></span> <a class="link" href="atomic.html#id2397131-bb">compare_exchange_strong</a>(Type &amp;, Type, memory_order, memory_order) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2397215-bb">exchange</a>(Type, memory_order = memory_order_seq_cst) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2421984-bb">fetch_add</a>(Type, memory_order = memory_order_seq_cst) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2422024-bb">fetch_sub</a>(Type, memory_order = memory_order_seq_cst) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2422080-bb">fetch_and</a>(Type, memory_order = memory_order_seq_cst) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2422137-bb">fetch_or</a>(Type, memory_order = memory_order_seq_cst) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2422184-bb">fetch_xor</a>(Type, memory_order = memory_order_seq_cst) ;
  <a class="link" href="atomic.html#id2422230-bb"><span class="bold"><strong>operator</strong></span> Type</a>(<span class="bold"><strong>void</strong></span>) <span class="bold"><strong>const</strong></span>;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2422259-bb"><span class="bold"><strong>operator</strong></span> &amp;=</a>(Type) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2422292-bb"><span class="bold"><strong>operator</strong></span>|=</a>(Type) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2422332-bb"><span class="bold"><strong>operator</strong></span>^=</a>(Type) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2422372-bb"><span class="bold"><strong>operator</strong></span>+=</a>(Type) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2422421-bb"><span class="bold"><strong>operator</strong></span>-=</a>(Type) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2422470-bb"><span class="bold"><strong>operator</strong></span>++</a>(<span class="bold"><strong>void</strong></span>) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2422508-bb"><span class="bold"><strong>operator</strong></span>++</a>(<span class="bold"><strong>int</strong></span>) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2422546-bb"><span class="bold"><strong>operator</strong></span>--</a>(<span class="bold"><strong>void</strong></span>) ;
  <span class="type">Type</span> <a class="link" href="atomic.html#id2422585-bb"><span class="bold"><strong>operator</strong></span>--</a>(<span class="bold"><strong>int</strong></span>) ;
};</pre></div>
<div class="refsect1" lang="en">
<a name="id3157857"></a><h2>Description</h2>
<p>An atomic variable. Provides methods to modify this variable atomically. Valid template parameters are:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>integral data types (char, short, int, ...)</p></li>
<li><p>pointer data types</p></li>
<li><p>any other data type that has a non-throwing default constructor and that can be copied via <code class="computeroutput">memcpy</code></p></li>
</ul></div>
<p>
</p>
<p>Unless specified otherwise, any memory ordering constraint can be used with any of the atomic operations. </p>
<div class="refsect2" lang="en">
<a name="id3157890"></a><h3>
<a name="boost.atomicconstruct-copy-destruct"></a><code class="computeroutput">atomic</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id2422623-bb"></a>atomic();</pre>Create uninitialized atomic variable Creates an atomic variable. Its initial value is undefined. </li>
<li>
<pre class="literallayout"><a name="id2457688-bb"></a>atomic(Type value);</pre>Create an initialize atomic variable. <p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><code class="computeroutput">value</code></span></p></td>
<td><p>Initial value Creates and initializes an atomic variable. </p></td>
</tr></tbody>
</table></div></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><a name="id2457730-bb"></a>atomic(<span class="bold"><strong>const</strong></span> <a class="link" href="atomic.html" title="Class template atomic">atomic</a> &amp;);</pre>Deleted copy constructor. </li>
<li>
<pre class="literallayout">atomic&amp; <a name="id2457704-bb"></a><span class="bold"><strong>operator</strong></span>=(Type v);</pre>Implicit store. <p>

The same as <code class="computeroutput">store(value, memory_order_seq_cst)</code>. Avoid using the implicit conversion operator, use store with an explicit memory ordering constraint. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Copy of <code class="computeroutput">value</code> </p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout">atomic&amp; <a name="id2457742-bb"></a><span class="bold"><strong>operator</strong></span>=(<span class="bold"><strong>const</strong></span> <a class="link" href="atomic.html" title="Class template atomic">atomic</a> &amp;);</pre>Deleted copy assignment. </li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3158058"></a><h3>
<a name="id2396681-bb"></a><code class="computeroutput">atomic</code> public member functions</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2396684-bb"></a>load(memory_order order = memory_order_seq_cst) <span class="bold"><strong>const</strong></span>;</pre>Read the current value of the atomic variable. <p>

Valid memory ordering constraints are:</p>
<div class="itemizedlist"><ul type="disc">
<li><p><code class="computeroutput">memory_order_relaxed</code> </p></li>
<li><p><code class="computeroutput">memory_order_consume</code> </p></li>
<li><p><code class="computeroutput">memory_order_acquire</code> </p></li>
<li><p><code class="computeroutput">memory_order_seq_cst</code> </p></li>
</ul></div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see Memory order </p></td>
</tr></tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Current value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2396740-bb"></a>store(Type value, memory_order order = memory_order_seq_cst) ;</pre>Write new value to atomic variable. <p>
Valid memory ordering constraints are:</p>
<div class="itemizedlist"><ul type="disc">
<li><p><code class="computeroutput">memory_order_relaxed</code> </p></li>
<li><p><code class="computeroutput">memory_order_release</code> </p></li>
<li><p><code class="computeroutput">memory_order_seq_cst</code> </p></li>
</ul></div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see Memory order</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">value</code></span></p></td>
<td><p>New value </p></td>
</tr>
</tbody>
</table></div></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id2396795-bb"></a>compare_exchange_weak(Type &amp; expected, Type desired, 
                           memory_order order = memory_order_seq_cst) ;</pre>Atomically compare and exchange variable. <p>

Atomically performs the following operation</p>
<pre class="programlisting">                if (variable==expected) {
                        variable=desired;
                        return true;
                } else {
                        expected=variable;
                        return false;
                }
</pre>
<p>This operation may fail "spuriously", i.e. the state of the variable is unchanged even though the expected value was found (this is the case on architectures using "load-linked"/"store conditional" to implement the operation).</p>
<p>The established memory order will be <code class="computeroutput">order</code> if the operation is successful. If the operation is unsuccesful, the memory order will be</p>
<div class="itemizedlist"><ul type="disc">
<li><p><code class="computeroutput">memory_order_relaxed</code> if <code class="computeroutput">order</code> is <code class="computeroutput">memory_order_acquire</code> , <code class="computeroutput">memory_order_relaxed</code> or <code class="computeroutput">memory_order_consume</code> </p></li>
<li><p><code class="computeroutput">memory_order_release</code> if <code class="computeroutput">order</code> is <code class="computeroutput">memory_order_acq_release</code> or <code class="computeroutput">memory_order_release</code> </p></li>
<li><p><code class="computeroutput">memory_order_seq_cst</code> if <code class="computeroutput">order</code> is <code class="computeroutput">memory_order_seq_cst</code> </p></li>
</ul></div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">desired</code></span></p></td>
<td><p>Desired new value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">expected</code></span></p></td>
<td><p>Expected old value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see Memory order </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p><code class="computeroutput">true</code> if value was changed</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id2396922-bb"></a>compare_exchange_weak(Type &amp; expected, Type desired, 
                           memory_order success_order, 
                           memory_order failure_order) ;</pre>Atomically compare and exchange variable. <p>

Atomically performs the following operation</p>
<pre class="programlisting">                if (variable==expected) {
                        variable=desired;
                        return true;
                } else {
                        expected=variable;
                        return false;
                }
</pre>
<p>This operation may fail "spuriously", i.e. the state of the variable is unchanged even though the expected value was found (this is the case on architectures using "load-linked"/"store conditional" to implement the operation).</p>
<p>The constraint imposed by <code class="computeroutput">success_order</code> may not be weaker than the constraint imposed by <code class="computeroutput">failure_order</code>. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">desired</code></span></p></td>
<td><p>Desired new value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">expected</code></span></p></td>
<td><p>Expected old value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">failure_order</code></span></p></td>
<td><p>Memory ordering constraint if operation is unsuccesful </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">success_order</code></span></p></td>
<td><p>Memory ordering constraint if operation is successful </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p><code class="computeroutput">true</code> if value was changed</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id2397005-bb"></a>compare_exchange_strong(Type &amp; expected, Type desired, 
                             memory_order order = memory_order_seq_cst) ;</pre>Atomically compare and exchange variable. <p>

Atomically performs the following operation</p>
<pre class="programlisting">                if (variable==expected) {
                        variable=desired;
                        return true;
                } else {
                        expected=variable;
                        return false;
                }
</pre>
<p>In contrast to compare_exchange_weak, this operation will never fail spuriously. Since compare-and-swap must generally be retried in a loop, implementors are advised to prefer compare_exchange_weak where feasible.</p>
<p>The established memory order will be <code class="computeroutput">order</code> if the operation is successful. If the operation is unsuccesful, the memory order will be</p>
<div class="itemizedlist"><ul type="disc">
<li><p><code class="computeroutput">memory_order_relaxed</code> if <code class="computeroutput">order</code> is <code class="computeroutput">memory_order_acquire</code> , <code class="computeroutput">memory_order_relaxed</code> or <code class="computeroutput">memory_order_consume</code> </p></li>
<li><p><code class="computeroutput">memory_order_release</code> if <code class="computeroutput">order</code> is <code class="computeroutput">memory_order_acq_release</code> or <code class="computeroutput">memory_order_release</code> </p></li>
<li><p><code class="computeroutput">memory_order_seq_cst</code> if <code class="computeroutput">order</code> is <code class="computeroutput">memory_order_seq_cst</code> </p></li>
</ul></div>
<p>
</p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">desired</code></span></p></td>
<td><p>Desired new value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">expected</code></span></p></td>
<td><p>Expected old value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see Memory order </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p><code class="computeroutput">true</code> if value was changed</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>bool</strong></span></span> <a name="id2397131-bb"></a>compare_exchange_strong(Type &amp; expected, Type desired, 
                             memory_order success_order, 
                             memory_order failure_order) ;</pre>Atomically compare and exchange variable. <p>

Atomically performs the following operation</p>
<pre class="programlisting">                if (variable==expected) {
                        variable=desired;
                        return true;
                } else {
                        expected=variable;
                        return false;
                }
</pre>
<p>In contrast to compare_exchange_weak, this operation will never fail spuriously. Since compare-and-swap must generally be retried in a loop, implementors are advised to prefer compare_exchange_weak where feasible.</p>
<p>The constraint imposed by <code class="computeroutput">success_order</code> may not be weaker than the constraint imposed by <code class="computeroutput">failure_order</code>. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">desired</code></span></p></td>
<td><p>Desired new value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">expected</code></span></p></td>
<td><p>Expected old value </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">failure_order</code></span></p></td>
<td><p>Memory ordering constraint if operation is unsuccesful </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">success_order</code></span></p></td>
<td><p>Memory ordering constraint if operation is successful </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p><code class="computeroutput">true</code> if value was changed</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2397215-bb"></a>exchange(Type value, memory_order order = memory_order_seq_cst) ;</pre>Atomically exchange variable. <p>

Atomically exchanges the value of the variable with the new value and returns its old value. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see Memory order </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">value</code></span></p></td>
<td><p>New value </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2421984-bb"></a>fetch_add(Type operand, memory_order order = memory_order_seq_cst) ;</pre>Atomically add and return old value. <p>

Atomically adds operand to the variable and returns its old value. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see Memory order </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2422024-bb"></a>fetch_sub(Type operand, memory_order order = memory_order_seq_cst) ;</pre>Atomically subtract and return old value. <p>

Atomically subtracts operand from the variable and returns its old value.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, <code class="computeroutput">operand</code> is of type <code class="computeroutput">ptrdiff_t</code> and the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see Memory order </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2422080-bb"></a>fetch_and(Type operand, memory_order order = memory_order_seq_cst) ;</pre>Atomically perform bitwise "AND" and return old value. <p>

Atomically performs bitwise "AND" with the variable and returns its old value.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, <code class="computeroutput">operand</code> is of type <code class="computeroutput">ptrdiff_t</code> and the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see Memory order </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2422137-bb"></a>fetch_or(Type operand, memory_order order = memory_order_seq_cst) ;</pre>Atomically perform bitwise "OR" and return old value. <p>

Atomically performs bitwise "OR" with the variable and returns its old value.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see Memory order </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2422184-bb"></a>fetch_xor(Type operand, memory_order order = memory_order_seq_cst) ;</pre>Atomically perform bitwise "XOR" and return old value. <p>

Atomically performs bitwise "XOR" with the variable and returns its old value.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr>
<tr>
<td><p><span class="term"><code class="computeroutput">order</code></span></p></td>
<td><p>Memory ordering constraint, see Memory order </p></td>
</tr>
</tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><a name="id2422230-bb"></a><span class="bold"><strong>operator</strong></span> Type(<span class="bold"><strong>void</strong></span>) <span class="bold"><strong>const</strong></span>;</pre>Implicit load. <p>
The same as <code class="computeroutput">load(memory_order_seq_cst)</code>. Avoid using the implicit conversion operator, use load with an explicit memory ordering constraint. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Current value of the variable</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2422259-bb"></a><span class="bold"><strong>operator</strong></span> &amp;=(Type operand) ;</pre>Atomically perform bitwise "AND" and return new value. <p>

The same as <code class="computeroutput">fetch_and(operand, memory_order_seq_cst)&amp;operand</code>. Avoid using the implicit bitwise "AND" operator, use fetch_and with an explicit memory ordering constraint. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr></tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>New value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2422292-bb"></a><span class="bold"><strong>operator</strong></span>|=(Type operand) ;</pre>Atomically perform bitwise "OR" and return new value. <p>

The same as <code class="computeroutput">fetch_or(operand, memory_order_seq_cst)|operand</code>. Avoid using the implicit bitwise "OR" operator, use fetch_or with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr></tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>New value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2422332-bb"></a><span class="bold"><strong>operator</strong></span>^=(Type operand) ;</pre>Atomically perform bitwise "XOR" and return new value. <p>

The same as <code class="computeroutput">fetch_xor(operand, memory_order_seq_cst)^operand</code>. Avoid using the implicit bitwise "XOR" operator, use fetch_xor with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr></tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>New value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2422372-bb"></a><span class="bold"><strong>operator</strong></span>+=(Type operand) ;</pre>Atomically add and return new value. <p>

The same as <code class="computeroutput">fetch_add(operand, memory_order_seq_cst)+operand</code>. Avoid using the implicit add operator, use fetch_add with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, <code class="computeroutput">operand</code> is of type <code class="computeroutput">ptrdiff_t</code> and the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr></tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>New value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2422421-bb"></a><span class="bold"><strong>operator</strong></span>-=(Type operand) ;</pre>Atomically subtract and return new value. <p>

The same as <code class="computeroutput">fetch_sub(operand, memory_order_seq_cst)-operand</code>. Avoid using the implicit subtract operator, use fetch_sub with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, <code class="computeroutput">operand</code> is of type <code class="computeroutput">ptrdiff_t</code> and the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody>
<tr>
<td><p><span class="term">Parameters:</span></p></td>
<td><div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term"><code class="computeroutput">operand</code></span></p></td>
<td><p>Operand </p></td>
</tr></tbody>
</table></div></td>
</tr>
<tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>New value of the variable</p></td>
</tr>
</tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2422470-bb"></a><span class="bold"><strong>operator</strong></span>++(<span class="bold"><strong>void</strong></span>) ;</pre>Atomically increment and return new value. <p>
The same as <code class="computeroutput">fetch_add(1, memory_order_seq_cst)+1</code>. Avoid using the implicit increment operator, use fetch_add with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>New value of the variable</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2422508-bb"></a><span class="bold"><strong>operator</strong></span>++(<span class="bold"><strong>int</strong></span>) ;</pre>Atomically increment and return old value. <p>
The same as <code class="computeroutput">fetch_add(1, memory_order_seq_cst)</code>. Avoid using the implicit increment operator, use fetch_add with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2422546-bb"></a><span class="bold"><strong>operator</strong></span>--(<span class="bold"><strong>void</strong></span>) ;</pre>Atomically subtract and return new value. <p>
The same as <code class="computeroutput">fetch_sub(1, memory_order_seq_cst)-1</code>. Avoid using the implicit increment operator, use fetch_sub with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>New value of the variable</p></td>
</tr></tbody>
</table></div>
</li>
<li>
<pre class="literallayout"><span class="type">Type</span> <a name="id2422585-bb"></a><span class="bold"><strong>operator</strong></span>--(<span class="bold"><strong>int</strong></span>) ;</pre>Atomically subtract and return old value. <p>
The same as <code class="computeroutput">fetch_sub(1, memory_order_seq_cst)</code>. Avoid using the implicit increment operator, use fetch_sub with an explicit memory ordering constraint.</p>
<p>This method is available only if <code class="computeroutput">Type</code> is an integral type or a non-void pointer type. If it is a pointer type, the operation is performed following the rules for pointer arithmetic in C++. </p>
<div class="variablelist"><table border="0">
<col align="left" valign="top">
<tbody><tr>
<td><p><span class="term">Returns:</span></p></td>
<td><p>Old value of the variable</p></td>
</tr></tbody>
</table></div>
</li>
</ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2009 Helge Bahmann<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../atomic/reference.html"><img src="../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../atomic/reference.html#header..var.lib.build.boost-trunk.libs.atomic.doc.atomic_hpp"><img src="../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="memory_order.html"><img src="../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>
